<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>彷徨う文脈 - 私と小鳥と鈴と</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@500&display=swap" rel="stylesheet">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f4f4f4;
            font-family: 'Shippori Mincho', serif;
            user-select: none;
            cursor: default;
            touch-action: none;
        }

        /* 中央のドロップゾーン */
        #drop-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35vw;
            height: 35vw;
            border-radius: 50%;
            z-index: 0;
            pointer-events: none;
        }

        #start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 35px;
            font-size: 1rem;
            letter-spacing: 0.3em;
            color: #333;
            border: 1px solid #333;
            background: rgba(255,255,255,0.9);
            cursor: pointer;
            z-index: 999;
            transition: all 0.5s;
        }
        
        #start-btn.pressed {
            background: #111;
            color: #fff;
            transform: translate(-50%, -50%) scale(0.95); 
        }
        
        #guide-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #aaa;
            font-size: 12px;
            letter-spacing: 0.4em;
            transition: opacity 1s;
            pointer-events: none;
            writing-mode: vertical-rl;
            opacity: 0;
        }

        /* ★題名と著者名のコンテナ（一本のライン） */
        #finale-container {
            position: absolute;
            writing-mode: vertical-rl;
            opacity: 0;
            transition: opacity 3s ease-in-out;
            z-index: 5;
            display: flex;
            flex-direction: column; 
            align-items: center; /* ★中央のラインを揃える */
            justify-content: flex-start; /* 上から順に並べる */
            gap: 2rem; /* 題名と作者の間の距離 */
            pointer-events: none;
        }
        
        .title-text { font-size: 1.8rem; color: #111; letter-spacing: 0.2em; white-space: nowrap; }
        .author-text { font-size: 1rem; color: #444; letter-spacing: 0.2em; white-space: nowrap; }

        @media (max-width: 600px) {
            #drop-zone { width: 60vw; height: 60vw; }
            .title-text { font-size: 1.4rem; }
            .author-text { font-size: 0.9rem; }
            #finale-container { gap: 1.5rem; }
        }

        .char {
            position: absolute;
            font-size: 1.6rem;
            color: #333;
            cursor: grab;
            padding: 20px;
            touch-action: none;
            z-index: 10;
            font-weight: 500;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: top 1s cubic-bezier(0.16, 1, 0.3, 1), left 1s cubic-bezier(0.16, 1, 0.3, 1), color 0.5s, transform 0.5s;
        }

        @media (max-width: 600px) {
            .char { font-size: 1.05rem; padding: 15px; }
        }

        .char.scattered {
            color: rgba(0, 0, 0, 0.5);
            transition: color 0.5s, transform 0.5s !important;
        }

        .char.dragging {
            color: rgba(0, 0, 0, 1);
            z-index: 100;
            transform: translate(-50%, -50%) scale(1.3) !important;
            transition: none !important;
        }

        .char.locked {
            color: #222;
            pointer-events: none;
            transition: all 1.2s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 1;
        }

        .char.locked.invisible-line { opacity: 0; transition: opacity 1.5s; }
        .char.locked.clarified { opacity: 1 !important; color: #000 !important; transition: opacity 2s, color 2s; }
    </style>
</head>
<body>

    <div id="drop-zone"></div>
    <div id="start-btn">物語を紡ぐ</div>
    <div id="guide-message">中央へ集めよ</div>
    
    <div id="finale-container">
        <div class="title-text">私と小鳥と鈴と</div>
        <div class="author-text">金子みすゞ</div>
    </div>

    <div id="container"></div>

    <script>
        const story = [
            "私が両手をひろげても、", "お空はちっとも飛べないが、",
            "飛べる小鳥は私のように、", "地面を速くは走れない。",
            "私がからだをゆすっても、", "きれいな音は出ないけど、",
            "あの鳴る鈴は私のように、", "たくさんな唄は知らないよ。",
            "鈴と、小鳥と、それから私、", "みんなちがって、みんないい。"
        ];

        const container = document.getElementById('container');
        const guideMsg = document.getElementById('guide-message');
        const startBtn = document.getElementById('start-btn');
        const finaleContainer = document.getElementById('finale-container');
        
        let currentLineIndex = 0;
        let allLockedChars = [];
        let floatingChars = [];
        let isAnimating = false;
        let layout = { startX: 0, startY: 0, lineHeight: 0, charHeight: 0 };

        function isMobile() { return window.innerWidth <= 600; }

        startBtn.addEventListener('click', () => {
            startBtn.classList.add('pressed');
            startBtn.style.opacity = 0;
            startBtn.style.pointerEvents = 'none';
            calculateLayout();
            spawnLine(0);
        });

        // ★左右余白を均等にする計算
        function calculateLayout() {
            const _isMobile = isMobile();
            const winW = window.innerWidth;
            const winH = window.innerHeight;

            layout.lineHeight = _isMobile ? 32 : 55;
            layout.charHeight = _isMobile ? 28 : 45;

            // 1. 本文と題名列の全幅を計算
            const bodyWidth = story.length * layout.lineHeight;
            const titleColWidth = _isMobile ? 40 : 80;
            const gap = _isMobile ? 20 : 60;
            const totalWidth = bodyWidth + gap + titleColWidth;

            // 2. 左右均等な余白を算出
            const sideMargin = (winW - totalWidth) / 2;

            // 3. 上揃え（天付き）の位置
            layout.startY = winH * 0.18; 

            // 4. 題名の位置（一番右の列）
            finaleContainer.style.right = `${sideMargin}px`;
            finaleContainer.style.top = `${layout.startY}px`;

            // 5. 本文の開始X（題名の左側）
            layout.startX = winW - sideMargin - titleColWidth - gap;
        }

        function spawnLine(lineIndex) {
            if (lineIndex >= story.length) {
                showFinale();
                return;
            }
            guideMsg.style.opacity = 0.4;
            const text = story[lineIndex];
            let currentLineChars = [];
            let lockedCount = 0;
            const lineX = layout.startX - (lineIndex * layout.lineHeight);

            text.split('').forEach((char, i) => {
                const span = document.createElement('div');
                span.textContent = char;
                span.classList.add('char');
                span.dataset.targetX = lineX;
                span.dataset.targetY = layout.startY + (i * layout.charHeight) + (layout.charHeight / 2);
                
                container.appendChild(span);
                currentLineChars.push(span);
                addDragEvents(span, () => {
                    lockedCount++;
                    if (lockedCount === text.length) {
                        currentLineChars.forEach(c => c.classList.add('invisible-line'));
                        setTimeout(() => spawnLine(++currentLineIndex), 800);
                    }
                });
                setTimeout(() => initFloatingChar(span), 50 + (i * 40));
            });
        }

        function showFinale() {
            guideMsg.style.opacity = 0;
            setTimeout(() => { finaleContainer.style.opacity = 1; }, 500);
            allLockedChars.forEach((char, index) => {
                setTimeout(() => {
                    char.classList.remove('invisible-line');
                    char.classList.add('clarified');
                }, index * 10);
            });
        }

        // --- 物理演算・ドラッグ処理 ---
        function initFloatingChar(el) {
            el.classList.add('scattered');
            const border = 50;
            let randomX, randomY;
            do {
                randomX = Math.random() * (window.innerWidth - border * 2) + border;
                randomY = Math.random() * (window.innerHeight - border * 2) + border;
            } while (Math.hypot(randomX - window.innerWidth / 2, randomY - window.innerHeight / 2) < 120);
            el.posX = randomX; el.posY = randomY;
            const speed = 0.2 + Math.random() * 0.3;
            const angle = Math.random() * Math.PI * 2;
            el.vx = Math.cos(angle) * speed; el.vy = Math.sin(angle) * speed;
            el.rot = (Math.random() - 0.5) * 60;
            floatingChars.push(el);
            if (!isAnimating) { isAnimating = true; requestAnimationFrame(animateFrame); }
        }

        function animateFrame() {
            const winW = window.innerWidth, winH = window.innerHeight, margin = 40;
            floatingChars.forEach(el => {
                if (el.classList.contains('dragging') || el.classList.contains('locked')) return;
                el.posX += el.vx; el.posY += el.vy;
                if (el.posX < margin || el.posX > winW - margin) el.vx *= -1;
                if (el.posY < margin || el.posY > winH - margin) el.vy *= -1;
                el.style.left = el.posX + 'px'; el.style.top = el.posY + 'px';
                el.style.transform = `translate(-50%, -50%) rotate(${el.rot}deg)`;
            });
            if (floatingChars.length > 0) requestAnimationFrame(animateFrame);
            else isAnimating = false;
        }

        function addDragEvents(el, onLock) {
            let isDragging = false, offsetX, offsetY;
            const start = (e) => {
                if (el.classList.contains('locked')) return;
                const rect = el.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2;
                el.style.left = centerX + 'px'; el.style.top = centerY + 'px';
                el.classList.remove('scattered'); el.classList.add('dragging');
                isDragging = true;
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                offsetX = clientX - centerX; offsetY = clientY - centerY;
            };
            const move = (e) => {
                if (!isDragging) return;
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                el.style.left = (clientX - offsetX) + 'px'; el.style.top = (clientY - offsetY) + 'px';
            };
            const end = () => {
                if (!isDragging) return;
                isDragging = false; el.classList.remove('dragging');
                const rect = el.getBoundingClientRect();
                const cX = rect.left + rect.width / 2, cY = rect.top + rect.height / 2;
                if (Math.hypot(cX - window.innerWidth / 2, cY - window.innerHeight / 2) < 150) {
                    el.classList.remove('scattered');
                    const idx = floatingChars.indexOf(el); if (idx > -1) floatingChars.splice(idx, 1);
                    el.style.left = el.dataset.targetX + 'px'; el.style.top = el.dataset.targetY + 'px';
                    el.style.transform = 'translate(-50%, -50%) rotate(0deg)'; el.style.writingMode = 'vertical-rl';
                    el.classList.add('locked'); allLockedChars.push(el);
                    onLock();
                } else { el.classList.add('scattered'); el.posX = cX; el.posY = cY; }
            };
            el.addEventListener('mousedown', start); window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
            el.addEventListener('touchstart', start, {passive: false}); window.addEventListener('touchmove', move, {passive: false}); window.addEventListener('touchend', end);
        }
    </script>
</body>
</html>
