<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>彷徨う文脈</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@500&display=swap" rel="stylesheet">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f4f4f4;
            font-family: 'Shippori Mincho', serif;
            user-select: none;
            cursor: default;
        }

        #drop-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 240px;
            height: 70%;
            border: 1px dashed #ccc;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 0;
            transition: all 0.5s;
        }
        
        #drop-zone::after {
            content: 'ここに文脈を集める';
            color: #bbb;
            font-size: 13px;
            writing-mode: vertical-rl;
            letter-spacing: 0.3em;
        }

        body.completed #drop-zone {
            border-color: transparent;
        }
        body.completed #drop-zone::after {
            opacity: 0;
        }

        .char {
            position: absolute;
            font-size: 2.2rem;
            color: rgba(0, 0, 0, 0.4);
            cursor: grab;
            padding: 30px;
            touch-action: none;
            z-index: 10;
            
            /* アニメーション設定 */
            animation-name: float;
            animation-iteration-count: infinite;
            animation-timing-function: ease-in-out;
            /* durationなどはJSでランダム設定 */
            
            transition: color 0.3s, opacity 0.3s; 
        }

        .char.dragging {
            animation: none; 
            color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            cursor: grabbing;
            transform: scale(1.2) rotate(0deg) !important;
        }

        .char.locked {
            animation: none;
            color: #000;
            pointer-events: none;
            transition: all 0.6s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 1;
        }

        @keyframes float {
            0% {
                transform: translate(0, 0) rotate(var(--r));
            }
            50% {
                /* ここで大きく動く */
                transform: translate(var(--mx), var(--my)) rotate(calc(var(--r) + 15deg));
            }
            100% {
                transform: translate(0, 0) rotate(var(--r));
            }
        }

    </style>
</head>
<body>

    <div id="drop-zone"></div>
    <div id="container"></div>

    <script>
        const text = "意味を拾う旅"; 
        const container = document.getElementById('container');
        let lockedCount = 0;

        function init() {
            const totalHeight = text.length * 55; 
            const startY = window.innerHeight / 2 - totalHeight / 2;

            text.split('').forEach((char, i) => {
                const span = document.createElement('div');
                span.textContent = char;
                span.classList.add('char');
                
                let randomX, randomY;
                do {
                    randomX = Math.random() * (window.innerWidth - 80);
                    randomY = Math.random() * (window.innerHeight - 80);
                } while (
                    randomX > window.innerWidth/2 - 150 && 
                    randomX < window.innerWidth/2 + 150
                );

                span.style.left = randomX + 'px';
                span.style.top = randomY + 'px';

                // ▼▼▼ 調整箇所：動きを大きくしました ▼▼▼
                
                // 1. 回転のバラつきを大きく（-60度 〜 60度）
                const randomRotate = (Math.random() - 0.5) * 120; 
                span.style.setProperty('--r', `${randomRotate}deg`);
                
                // 2. 移動範囲を大きく（-60px 〜 60px）
                // ※前回の3倍くらい動きます
                const moveRange = 120; 
                const moveX = (Math.random() - 0.5) * moveRange + 'px';
                const moveY = (Math.random() - 0.5) * moveRange + 'px';
                span.style.setProperty('--mx', moveX);
                span.style.setProperty('--my', moveY);

                // 3. 速度にもっとバラつきを持たせる（3秒〜8秒）
                span.style.animationDuration = (3 + Math.random() * 5) + 's';
                span.style.animationDelay = (Math.random() * -5) + 's';

                // ▲▲▲ 調整ここまで ▲▲▲

                span.dataset.targetX = window.innerWidth / 2 - 20; 
                span.dataset.targetY = startY + (i * 65); 

                container.appendChild(span);
                addDragEvents(span);
            });
        }

        function addDragEvents(el) {
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            const start = (e) => {
                if (el.classList.contains('locked')) return;
                
                isDragging = true;
                el.classList.add('dragging');
                
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                startX = clientX;
                startY = clientY;
                
                initialLeft = parseFloat(el.style.left);
                initialTop = parseFloat(el.style.top);
            };

            const move = (e) => {
                if (!isDragging) return;
                e.preventDefault();

                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startX;
                const dy = clientY - startY;

                el.style.left = `${initialLeft + dx}px`;
                el.style.top = `${initialTop + dy}px`;
            };

            const end = () => {
                if (!isDragging) return;
                isDragging = false;
                el.classList.remove('dragging');

                const rect = el.getBoundingClientRect();
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                const dist = Math.hypot(rect.left + rect.width/2 - centerX, rect.top + rect.height/2 - centerY);

                if (dist < 120) {
                    snapToTarget(el);
                }
            };

            el.addEventListener('mousedown', start);
            window.addEventListener('mousemove', move);
            window.addEventListener('mouseup', end);

            el.addEventListener('touchstart', start, {passive: false});
            window.addEventListener('touchmove', move, {passive: false});
            window.addEventListener('touchend', end);
        }

        function snapToTarget(el) {
            el.style.left = el.dataset.targetX + 'px';
            el.style.top = el.dataset.targetY + 'px';
            el.style.transform = 'translate(0,0) rotate(0deg)';
            el.style.writingMode = 'vertical-rl';
            el.classList.add('locked');
            
            lockedCount++;
            if (lockedCount === text.length) {
                document.body.classList.add('completed');
            }
        }

        init();
    </script>
</body>
</html>
